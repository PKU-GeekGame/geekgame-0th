<style>
img {
    max-height: 30em;
    max-width: 80%;
    box-shadow: 0 1px 0.5em rgba(0, 0, 0, .25);
}
body {
    background-color: #f3f3f3;
}
#write {
    max-width: 900px !important;
    box-shadow: 0 0 2em rgba(0, 0, 0, .15);
    background-color: white;
}
#write p {
    margin: 1em 0;
}
</style>

# 巴别压缩包

题目材料源自于去年暑假闲的无聊研究DEFLATE算法的成果。quine的构造参考 https://research.swtch.com/zip 及 https://matthewbarber.io/gzip-quine/ ，实现的时候每个“指令”用了4个字节而不是5个字节，其余结构与文章中类似。CRC32的部分是作为一个数学练习附赠的（
因为出题时倾向于出得简单，而且为了毕业季不花太多时间在活动上，所以做成了一道纯文本描述的填空题（这样就不用管什么前端后端的了），选手自己通过解压程序验证题目，解出问题的选手还可以获得一个自我嵌套的zip文件作奖励（太省事了

本题考察的内容是理解zip文件的部分压缩原理（至少要知道压缩文件数据可以包含未经处理的原数据），根据题目要求推断出挖掉的部分均为相同的CRC32校验码，巧妙之处在于zip文件格式中的CRC32为解压后文件的CRC32数据，而为使得解压后的文件与原压缩文件相同，这一CRC32数据被包含在了解压后的文件里，也同时被包含在解压前的文件的数据部分。这就要求更改CRC32数据的同时还要使得整个文件的CRC32结果与更改的数据相同。
CRC32的算法大家网上都可以查到，通过穷举得出答案也不难，也有一部分选手的writeup中写到利用了CRC32的可加性（线性结构），但要漂亮地解决本问题，我们还需要利用到CRC32中的乘法（可除代数）结构：

我们知道对二进制数据的异或和移位操作给出一个F~2~（由2个元素组成的有限域，其中加法是异或操作，乘法是与操作）上的多项式环F~2~[x]（x的多项式，每项之前的系数在F~2~中），由CRC32算法中的常数`0xEDB88320`给出多项式
> q=x^32^+x^26^+x^23^+x^22^+x^16^+x^12^+x^11^+x^10^+x^8^+x^7^+x^5^+x^4^+x^2^+x^1^+x^0^

CRC32算法的结果是将文件作为一个多项式计算其对q作带余除法得到的余数，若像初等数论中对每个运算都进行模q取余数的操作，我们可以得到有限域[F~2^32~](https://en.wikipedia.org/wiki/Finite_field)上的代数运算。理解这一点后我们可以将CRC32的结果包含在要计算的数据中的情况转化为一个线性方程的求解：

为方便与多项式的次数对齐，将数据和变量表示为
```
data:
Byte  ... 4       3       2       1       0
bit   ...         31  . . . . .   876543210
poly  ...        x^-31                   x^0
crc:
Byte  3       2       1       0
bit   31   . . . . .  876543210
poly x^0                     x^31
```
余数初始化为`0xFFFFFFFF`，在数据末尾添加`0xFFFFFFFF`后计算带余除法

我们假设填进的数据为crc，在不同位置填入crc相当于对数据做移位与异或，在代数上就是乘以某个多项式(记为K)
> crc * (x^n1^ + x^n2^ + x^n3^ + x^n4^) = crc * K

在Z2[x]环中（略去x及次数）约束条件可写成：
```
(filedata + K * crc) (concat) ffffffff + crc === 0   mod q
(filedata + K * crc)*x^32 + ffffffff + crc === 0     mod q
filedata*x^32 + ffffffff === (K*x^32 + 1) * crc      mod q
```
解这个同余方程只需求出常数项`filedata*x^32 + ffffffff`与`K*x^32 + 1`系数项的逆元（参考初等数论中2*3 === 1 mod 5)即可，实际上若有现成的CRC32算法可以通过对不同crc计算两次文件CRC32得出系数项。求逆元的过程实际实现为[辗转相除法](https://en.wikipedia.org/wiki/Euclidean_algorithm)。具体算法见crc32-crack.cpp

若题目条件放宽松，允许选手在足够长(>=4字节)的空间里写入任意数据的则有其他的方法构造出合法的zip文件：
https://www.nayuki.io/page/forcing-a-files-crc-to-any-value

想着让不熟悉代数的同学也能做出来所以没有做防止暴力穷举的设计，结果writeup中没有一个人选择使用代数方法，看来暴力穷举的难度还是太低了（
（防穷举设计思路：显然如果我们对quine.zip文件进行更多的构造使其包含更多的文件结构，那么我们需要的CRC32验证码就会形成二元或以上的线性方程组，这时候就需要用线性代数方法求解（你解过F~2^32~上的线性方程组吗？），同时使得穷举的搜索空间变为原先的2次方以上

题目描述拙劣地模仿了博尔赫斯的《巴别图书馆》，原文中图书馆里的书遍历了所有可能的字母排列，但书的总数是有限的，这里虽然压缩包的大小也是有限的，但是通过解压算法的重复操作又可能衍生出无限的内容。（关于给出一个越解压越大的压缩包的构造给有兴趣的同学作为课后练习

）））））